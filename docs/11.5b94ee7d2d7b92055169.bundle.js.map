{"version":3,"file":"11.5b94ee7d2d7b92055169.bundle.js","sources":["webpack:///../node_modules/@vaadin/vaadin-list-box/vaadin-list-box.js","webpack:///../node_modules/@vaadin/vaadin-list-mixin/vaadin-list-mixin.js","webpack:///../node_modules/@vaadin/vaadin-list-box/src/vaadin-list-box.js"],"sourcesContent":["import './theme/lumo/vaadin-list-box.js';\n","/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { FlattenedNodesObserver } from '@polymer/polymer/lib/utils/flattened-nodes-observer.js';\n\n/**\n * A mixin for `nav` elements, facilitating navigation and selection of childNodes.\n *\n * @polymerMixin\n */\nexport const ListMixin = superClass => class VaadinListMixin extends superClass {\n  static get properties() {\n    return {\n      /**\n       * Used for mixin detection because `instanceof` does not work with mixins.\n       */\n      _hasVaadinListMixin: {\n        value: true\n      },\n\n      /**\n       * The index of the item selected in the items array\n       */\n      selected: {\n        type: Number,\n        reflectToAttribute: true,\n        notify: true\n      },\n\n      /**\n       * Define how items are disposed in the dom.\n       * Possible values are: `horizontal|vertical`.\n       * It also changes navigation keys from left/right to up/down.\n       */\n      orientation: {\n        type: String,\n        reflectToAttribute: true,\n        value: ''\n      },\n\n      /**\n       * The list of items from which a selection can be made.\n       * It is populated from the elements passed to the light DOM,\n       * and updated dynamically when adding or removing items.\n       *\n       * The item elements must implement `Vaadin.ItemMixin`.\n       *\n       * Note: unlike `<vaadin-combo-box>`, this property is read-only,\n       * so if you want to provide items by iterating array of data,\n       * you have to use `dom-repeat` and place it to the light DOM.\n       */\n      items: {\n        type: Array,\n        readOnly: true,\n        notify: true\n      }\n    };\n  }\n\n  static get observers() {\n    return ['_enhanceItems(items, orientation, selected)'];\n  }\n\n  ready() {\n    super.ready();\n    this.addEventListener('keydown', e => this._onKeydown(e));\n    this.addEventListener('click', e => this._onClick(e));\n\n    this._observer = new FlattenedNodesObserver(this, info => {\n      this._setItems(this._filterItems(Array.from(this.children)));\n    });\n  }\n\n  _enhanceItems(items, orientation, selected) {\n    if (items) {\n      this.setAttribute('aria-orientation', orientation || 'vertical');\n      this.items.forEach(item => {\n        orientation ? item.setAttribute('orientation', orientation) : item.removeAttribute('orientation');\n        item.updateStyles();\n      });\n\n      this._setFocusable(selected);\n\n      const itemToSelect = items[selected];\n      items.forEach(item => item.selected = item === itemToSelect);\n      if (itemToSelect && !itemToSelect.disabled) {\n        this._scrollToItem(selected);\n      }\n    }\n  }\n\n  get focused() {\n    return this.getRootNode().activeElement;\n  }\n\n  _filterItems(array) {\n    return array.filter(e => e._hasVaadinItemMixin);\n  }\n\n  _onClick(event) {\n    if (event.metaKey || event.shiftKey || event.ctrlKey) {\n      return;\n    }\n\n    const item = this._filterItems(event.composedPath())[0];\n    let idx;\n    if (item && !item.disabled && ((idx = this.items.indexOf(item)) >= 0)) {\n      this.selected = idx;\n    }\n  }\n\n  _onKeydown(event) {\n    if (event.metaKey || event.ctrlKey) {\n      return;\n    }\n\n    // IE names for arrows do not include the Arrow prefix\n    const key = event.key.replace(/^Arrow/, '');\n\n    const currentIdx = this.items.indexOf(this.focused);\n    let condition = item => !item.disabled;\n    let idx, increment;\n\n    if (this._vertical && key === 'Up' || !this._vertical && key === 'Left') {\n      increment = -1;\n      idx = currentIdx - 1;\n    } else if (this._vertical && key === 'Down' || !this._vertical && key === 'Right') {\n      increment = 1;\n      idx = currentIdx + 1;\n    } else if (key === 'Home') {\n      increment = 1;\n      idx = 0;\n    } else if (key === 'End') {\n      increment = -1;\n      idx = this.items.length - 1;\n    } else if (key.length == 1) {\n      increment = 1;\n      idx = currentIdx + 1;\n      condition = item => !item.disabled &&\n        item.textContent.trim().toLowerCase().indexOf(key.toLowerCase()) === 0;\n    }\n\n    idx = this._getAvailableIndex(idx, increment, condition);\n    if (idx >= 0) {\n      this._focus(idx);\n      event.preventDefault();\n    }\n  }\n\n  _getAvailableIndex(idx, increment, condition) {\n    const totalItems = this.items.length;\n    for (let i = 0; typeof idx == 'number' && i < totalItems; i++, idx += (increment || 1)) {\n      if (idx < 0) {\n        idx = totalItems - 1;\n      } else if (idx >= totalItems) {\n        idx = 0;\n      }\n\n      const item = this.items[idx];\n      if (condition(item)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  _setFocusable(idx) {\n    idx = this._getAvailableIndex(idx, 1, item => !item.disabled);\n    const item = this.items[idx] || this.items[0];\n    this.items.forEach(e => e.tabIndex = e === item ? 0 : -1);\n  }\n\n  _focus(idx) {\n    const item = this.items[idx];\n    this.items.forEach(e => e.focused = e === item);\n    this._setFocusable(idx);\n    this._scrollToItem(idx);\n    item.focus();\n  }\n\n  focus() {\n    // In initialisation (e.g vaadin-select) observer might not been run yet.\n    this._observer.flush();\n    const firstItem = (this.querySelector('[tabindex=\"0\"]') || this.items[0]);\n    firstItem && firstItem.focus();\n  }\n\n  /* @protected */\n  get _scrollerElement() {\n    // Returning scroller element of the component\n  }\n\n  // Scroll the container to have the next item by the edge of the viewport\n  _scrollToItem(idx) {\n    const item = this.items[idx];\n    if (!item) {\n      return;\n    }\n\n    const props = this._vertical ? ['top', 'bottom'] : ['left', 'right'];\n    const scrollerRect = this._scrollerElement.getBoundingClientRect();\n    const nextItemRect = (this.items[idx + 1] || item).getBoundingClientRect();\n    const prevItemRect = (this.items[idx - 1] || item).getBoundingClientRect();\n\n    let scrollDistance = 0;\n    if (nextItemRect[props[1]] >= scrollerRect[props[1]]) {\n      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];\n    } else if (prevItemRect[props[0]] <= scrollerRect[props[0]]) {\n      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];\n    }\n\n    this._scroll(scrollDistance);\n  }\n\n  /* @protected */\n  get _vertical() {\n    return this.orientation !== 'horizontal';\n  }\n\n  _scroll(pixels) {\n    this._scrollerElement['scroll' + (this._vertical ? 'Top' : 'Left')] += pixels;\n  }\n};\n","/**\n@license\nCopyright (c) 2017 Vaadin Ltd.\nThis program is available under Apache License Version 2.0, available at https://vaadin.com/license/\n*/\nimport { PolymerElement } from '@polymer/polymer/polymer-element.js';\n\nimport { ThemableMixin } from '@vaadin/vaadin-themable-mixin/vaadin-themable-mixin.js';\nimport { ListMixin } from '@vaadin/vaadin-list-mixin/vaadin-list-mixin.js';\nimport { ElementMixin } from '@vaadin/vaadin-element-mixin/vaadin-element-mixin.js';\nimport { html } from '@polymer/polymer/lib/utils/html-tag.js';\n/**\n * `<vaadin-list-box>` is a Web Component for creating menus.\n *\n * ```\n *   <vaadin-list-box selected=\"2\">\n *     <vaadin-item>Item 1</vaadin-item>\n *     <vaadin-item>Item 2</vaadin-item>\n *     <vaadin-item>Item 3</vaadin-item>\n *     <vaadin-item>Item 4</vaadin-item>\n *   </vaadin-list-box>\n * ```\n *\n * ### Styling\n *\n * The following shadow DOM parts are available for styling:\n *\n * Part name         | Description\n * ------------------|------------------------\n * `items`           | The items container\n *\n * See [ThemableMixin â€“ how to apply styles for shadow parts](https://github.com/vaadin/vaadin-themable-mixin/wiki)\n *\n * @memberof Vaadin\n * @mixes Vaadin.ListMixin\n * @mixes Vaadin.ThemableMixin\n * @demo demo/index.html\n */\nclass ListBoxElement extends ElementMixin(ListMixin(ThemableMixin(PolymerElement))) {\n  static get template() {\n    return html`\n    <style>\n      :host {\n        display: flex;\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      [part=\"items\"] {\n        height: 100%;\n        width: 100%;\n        overflow-y: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n    </style>\n    <div part=\"items\">\n      <slot></slot>\n    </div>\n`;\n  }\n\n  static get is() {\n    return 'vaadin-list-box';\n  }\n\n  static get version() {\n    return '1.1.0';\n  }\n\n  static get properties() {\n    return {\n      // We don't need to define this property since super default is vertical,\n      // but we don't want it to be modified, or be shown in the API docs.\n      /** @private */\n      orientation: {\n        readOnly: true\n      }\n    };\n  }\n\n  ready() {\n    super.ready();\n    this.setAttribute('role', 'list');\n  }\n\n  get _scrollerElement() {\n    return this.shadowRoot.querySelector('[part=\"items\"]');\n  }\n}\n\ncustomElements.define(ListBoxElement.is, ListBoxElement);\n\nexport { ListBoxElement };\n"],"mappings":"AAAA;;;;;ACYA;;;;;AC0BA","sourceRoot":""}